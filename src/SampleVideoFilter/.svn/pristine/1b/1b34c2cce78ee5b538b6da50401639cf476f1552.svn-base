#include <windows.h>
#include <commctrl.h>
#include <gdiplus.h>
#include <stdio.h>
#include <vector>

#include <vd2/VDXFrame/VideoFilter.h>
#include <vd2/VDXFrame/VideoFilterDialog.h>
#include "../resource.h"
#include "gdiplusheaders.h"

#include "pugixml.hpp"

#define _USE_MATH_DEFINES
#include "math.h"

using namespace Gdiplus;
#pragma comment (lib,"Gdiplus.lib")

extern int g_VFVAPIVersion;

///////////////////////////////////////////////////////////////////////////////

#pragma region ConfigDialog

class RouteFilterConfig {
public:
	RouteFilterConfig()
	{
		strcpy_s(mFile, sizeof(mFile)/sizeof(mFile[0]), "c:\\rgmapvideo\\settings.xml");
	}

public:
	char mFile[1024];
};

///////////////////////////////////////////////////////////////////////////////

class RouteFilterDialog : public VDXVideoFilterDialog {
public:
	RouteFilterDialog(RouteFilterConfig& config, IVDXFilterPreview *ifp) : mConfig(config) /*, mifp(ifp)*/ {}

	bool Show(HWND parent) {
		return 0 != VDXVideoFilterDialog::Show(NULL, MAKEINTRESOURCE(IDD_FILTER_ROUTE_DLG), parent);
	}

	virtual INT_PTR DlgProc(UINT msg, WPARAM wParam, LPARAM lParam);

protected:
	bool OnInit();
	bool OnCommand(int cmd);
	void OnDestroy();

	void LoadFromConfig();
	bool SaveToConfig();

	RouteFilterConfig& mConfig;
	RouteFilterConfig mOldConfig;
};

INT_PTR RouteFilterDialog::DlgProc(UINT msg, WPARAM wParam, LPARAM lParam) {
	switch(msg) {
		case WM_INITDIALOG:
			return !OnInit();

		case WM_DESTROY:
			OnDestroy();
			break;

		case WM_COMMAND:
			if (OnCommand(LOWORD(wParam)))
				return TRUE;
			break;
	}

	return FALSE;
}

bool RouteFilterDialog::OnInit() {
	mOldConfig = mConfig;

	LoadFromConfig();

	return false;
}

void RouteFilterDialog::OnDestroy() {
}

bool RouteFilterDialog::OnCommand(int cmd) {
	switch(cmd) {
		case IDOK:
			SaveToConfig();
			EndDialog(mhdlg, true);
			return true;

		case IDCANCEL:
			mConfig = mOldConfig;
			EndDialog(mhdlg, false);
			return true;

		case IDC_BROWSE:
			{
				OPENFILENAME ofn; 
				char szFile[1024];
				// Initialize OPENFILENAME
				ZeroMemory(&ofn, sizeof(ofn));
				ofn.lStructSize = sizeof(ofn);
				ofn.hwndOwner = mhdlg;
				ofn.lpstrFile = szFile;
				// Set lpstrFile[0] to '\0' so that GetOpenFileName does not 
				// use the contents of szFile to initialize itself.
				ofn.lpstrFile[0] = '\0';
				ofn.nMaxFile = sizeof(szFile);
				ofn.lpstrFilter = "All\0*.*\0XML\0*.xml\0";
				ofn.nFilterIndex = 1;
				ofn.lpstrFileTitle = NULL;
				ofn.nMaxFileTitle = 0;
				ofn.lpstrInitialDir = NULL;
				ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

				// Display the Open dialog box. 

				if (GetOpenFileName(&ofn)==TRUE) 
				{
					SetDlgItemText(mhdlg, IDC_FILE, szFile);
					SaveToConfig();
				}
			}
			return true;
	}

	return false;
}

void RouteFilterDialog::LoadFromConfig() 
{
	SetDlgItemText(mhdlg, IDC_FILE, mConfig.mFile);
}

bool RouteFilterDialog::SaveToConfig() 
{
	char file_name[1024];
	UINT retI = GetDlgItemText(mhdlg, IDC_FILE, file_name, 1024);
	retI = strcmp(mConfig.mFile, file_name);
	strcpy_s(mConfig.mFile, 1024, file_name);
    bool ret = retI != 0; 
	return ret;
}

#pragma endregion ConfigDialog

///////////////////////////////////////////////////////////////////////////////

class RouteFilter : public VDXVideoFilter {
public:
    RouteFilter() : 
      m_pLegMatrix(NULL),
      m_pLastBmp(NULL),
      m_pSettingsDoc(NULL),
      m_pPathDoc(NULL),
      m_pMap(NULL), 
      m_pLogo(NULL), 
      m_pPointer(NULL),
      m_pPenTail(NULL),
      m_pPenLeg(NULL),
      m_pTimeBrush(NULL), 
      m_pTimeFont(NULL),
      m_pPaceBrush(NULL), 
      m_pPaceFont(NULL)
    {
        gdiplusToken = NULL;
    }

    RouteFilter::RouteFilter(const RouteFilter &f)
    {
        mConfig = f.mConfig;
        gdiplusToken = NULL;
        m_pLastBmp = NULL;
        m_pSettingsDoc = NULL;
        m_pPathDoc = NULL;
        m_pMap = NULL; 
        m_pLogo = NULL; 
        m_pPointer = NULL;
        m_pPenTail = NULL;
        m_pPenLeg = NULL;
        m_pTimeBrush = NULL; 
        m_pTimeFont = NULL;
        m_pPaceBrush = NULL; 
        m_pPaceFont = NULL;
        m_pLegMatrix = NULL;
    }

    virtual ~RouteFilter();

	virtual uint32 GetParams();
    virtual bool Init();
	virtual void Start();
	virtual void Run();
	virtual void End();
	virtual bool Configure(VDXHWND hwnd);
	virtual void GetSettingString(char *buf, int maxlen);
	virtual void GetScriptString(char *buf, int maxlen);

	VDXVF_DECLARE_SCRIPT_METHODS();

protected:
    Bitmap *PrepareRGB32(void* data, uint32 pitch, uint32 w, uint32 h);
	void DrawRoute(Bitmap *bmp, uint32 ms);
    void ApplyRGB32(Bitmap *bmp, void* data, uint32 pitch, uint32 w, uint32 h);

	void ScriptConfig(IVDXScriptInterpreter *isi, const VDXScriptValue *argv, int argc);

	RouteFilterConfig	mConfig;
	GdiplusStartupInput gdiplusStartupInput;
	ULONG_PTR           gdiplusToken;

   	pugi::xml_document *m_pSettingsDoc;
    Bitmap             *m_pMap;

    Bitmap             *m_pPointer;
    int                 m_PointerOpaque;
    int                 m_PosOpaque, m_PosX, m_PosY, m_PosWidth, m_PosHeight;
    int                 m_PosTail;
    Pen                *m_pPenTail;

    Matrix             *m_pLegMatrix;
    std::vector<PointF> m_LegPoints;
    int                 m_LegPositon;
    int                 m_LegOpaque, m_LegX, m_LegY, m_LegWidth, m_LegHeight, m_LegTreshold;
    Pen                *m_pPenLeg;

    Bitmap             *m_pLogo;
    int                 m_LogoOpaque, m_LogoX, m_LogoY;

    int32               m_TimeOffset;   //ms
    
    PointF              m_TimePos;
    Font               *m_pTimeFont;
    SolidBrush         *m_pTimeBrush;
   	
    PointF              m_PacePos;
    Font               *m_pPaceFont;
    SolidBrush         *m_pPaceBrush;
    int                 m_AvgTail;

    pugi::xml_document *m_pPathDoc;

    pugi::xml_node      m_LastSample;
    Bitmap             *m_pLastBmp;
};

VDXVF_BEGIN_SCRIPT_METHODS(RouteFilter)
VDXVF_DEFINE_SCRIPT_METHOD(RouteFilter, ScriptConfig, "s")
VDXVF_END_SCRIPT_METHODS()

uint32 RouteFilter::GetParams() {
	if (g_VFVAPIVersion >= 12) {
		switch(fa->src.mpPixmapLayout->format) {
			case nsVDXPixmap::kPixFormat_XRGB8888:
				break;

			default:
				return FILTERPARAM_NOT_SUPPORTED;
		}
	}

	fa->dst.offset = fa->src.offset;
	return FILTERPARAM_SUPPORTS_ALTFORMATS;
}



RouteFilter::~RouteFilter()
{
    if (gdiplusToken)
    {
    	//GdiplusShutdown(gdiplusToken);
        gdiplusToken = NULL;
    }
}

bool RouteFilter::Init()
{
    bool ret = VDXVideoFilter::Init();

	if (gdiplusToken == NULL)
    {
        // Initialize GDI+.
	    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);
    }

    return ret;
}

#define CapsCharToVal(x) (*(x)>'9'?*(x)-'A'+10:*(x)-'0')
#define CapsCharToVal2(x) (CapsCharToVal(x+1)|(CapsCharToVal(x)<<4))

Color ColorFromStr(const char* str)
{
    if (str == NULL && *str == '0') return Color(0,0,0,0);
    BYTE a = CapsCharToVal2(str);
    BYTE r = CapsCharToVal2(str+2);
    BYTE g = CapsCharToVal2(str+4);
    BYTE b = CapsCharToVal2(str+6);
    return Color(a,r,g,b);
}

void RouteFilter::Start() 
{
    if (mConfig.mFile[0] != 0)
    {
        m_pSettingsDoc = new pugi::xml_document();
        pugi::xml_parse_result result = m_pSettingsDoc->load_file(mConfig.mFile);
        pugi::xml_node settings = m_pSettingsDoc->child("RouteAddSettings");

        //setup time position 
        pugi::xml_node time_pos = settings.child("Time");
        WCHAR font_name[1024];
        size_t converted;
        mbstowcs_s(&converted, font_name, _countof(font_name), time_pos.attribute("font").as_string(), _TRUNCATE); 
        m_pTimeFont = new Font(font_name, time_pos.attribute("size").as_float());
        m_pTimeBrush = new SolidBrush(ColorFromStr(time_pos.attribute("color").as_string())); 
        m_TimePos.X = time_pos.attribute("x").as_float();
        m_TimePos.Y = time_pos.attribute("y").as_float();

        //load map file image
        pugi::xml_node map_file = settings.child("MapFile");

        WCHAR file_name[1024];
        mbstowcs_s(&converted, file_name, _countof(file_name), map_file.child_value(), _TRUNCATE); 
        m_pMap = Bitmap::FromFile(file_name);

        //load logo image
        pugi::xml_node logo_file = settings.child("Logo");

        mbstowcs_s(&converted, file_name, _countof(file_name), logo_file.child_value(), _TRUNCATE); 
        m_pLogo = Bitmap::FromFile(file_name);
        m_LogoX = logo_file.attribute("x").as_int();
        m_LogoY = logo_file.attribute("y").as_int();
        m_LogoOpaque = logo_file.attribute("opaq").as_int();

        //setup pointer 
        pugi::xml_node pointer_map = settings.child("Pointer");
        mbstowcs_s(&converted, file_name, _countof(file_name), pointer_map.child_value(), _TRUNCATE); 
        m_pPointer = Bitmap::FromFile(file_name);
        m_PointerOpaque = pointer_map.attribute("opaq").as_int();

        //setup pos view 
        pugi::xml_node pos_map = settings.child("PosMap");
        m_PosX = pos_map.attribute("x").as_int();
        m_PosY = pos_map.attribute("y").as_int();
        m_PosWidth = pos_map.attribute("w").as_int();
        m_PosHeight = pos_map.attribute("h").as_int();
        m_PosOpaque = pos_map.attribute("opaq").as_int();
        m_PosTail = pos_map.attribute("tail").as_int();
        REAL  pen_size = pos_map.attribute("size").as_float();
        m_pPenTail = new Pen(ColorFromStr(pos_map.attribute("color").as_string()), pen_size);

        //setup leg view 
        pugi::xml_node leg_map = settings.child("Leg");
        m_LegX = leg_map.attribute("x").as_int();
        m_LegY = leg_map.attribute("y").as_int();
        m_LegWidth = leg_map.attribute("w").as_int();
        m_LegHeight = leg_map.attribute("h").as_int();
        m_LegOpaque = leg_map.attribute("opaq").as_int();
        m_LegTreshold = leg_map.attribute("treshold").as_int();
        pen_size = leg_map.attribute("size").as_float();
        m_pPenLeg = new Pen(ColorFromStr(leg_map.attribute("color").as_string()), pen_size);

        //load path
        pugi::xml_node path_file = settings.child("PathFile");
        m_pPathDoc = new pugi::xml_document();
        result = m_pPathDoc->load_file(path_file.child_value());
        pugi::xml_node empty_node;
        m_LastSample = empty_node;// m_pPathDoc->child("Route").child("Segment").first_child();
        m_TimeOffset = path_file.attribute("offset").as_int();

        //setup pace
        pugi::xml_node pace_pos = settings.child("Pace");
        mbstowcs_s(&converted, font_name, _countof(font_name), pace_pos.attribute("font").as_string(), _TRUNCATE); 
        m_pPaceFont = new Font(font_name, pace_pos.attribute("size").as_float());
        m_pPaceBrush = new SolidBrush(ColorFromStr(pace_pos.attribute("color").as_string())); 
        m_PacePos.X = pace_pos.attribute("x").as_float();
        m_PacePos.Y = pace_pos.attribute("y").as_float();
        m_AvgTail = pace_pos.attribute("avg").as_int();

        pugi::xml_node pulse_pos = settings.child("Pulse");

    }
}

void RouteFilter::End()
{
    if (m_pLegMatrix)
    {
        delete m_pLegMatrix;
        m_pLegMatrix = NULL;
    }
    if (m_pLastBmp)
    {
        delete m_pLastBmp;
        m_pLastBmp = NULL;
    }
    if (m_pPenTail)
    {
        delete m_pPenTail;
        m_pPenTail = NULL;
    }
    if (m_pPenLeg)
    {
        delete m_pPenLeg;
        m_pPenLeg = NULL;
    }
    if (m_pLogo)
    {
        delete m_pLogo;
        m_pLogo = NULL;
    }
    if (m_pPointer)
    {
        delete m_pLogo;
        m_pLogo = NULL;
    }
    if (m_pTimeFont)
    {
        delete m_pTimeFont;
        m_pTimeFont = NULL;
    }
    if (m_pTimeBrush)
    {
        delete m_pTimeBrush;
        m_pTimeBrush = NULL;
    }
    if (m_pPaceFont)
    {
        delete m_pPaceFont;
        m_pPaceFont = NULL;
    }
    if (m_pPaceBrush)
    {
        delete m_pPaceBrush;
        m_pPaceBrush = NULL;
    }
    if (m_pMap)
    {
        delete m_pMap;
        m_pMap = NULL;
    }

    if (m_pPathDoc)
    {
        delete m_pPathDoc;
        m_pPathDoc = NULL;
    }

    if (m_pSettingsDoc)
    {
        delete m_pSettingsDoc;
        m_pSettingsDoc = NULL;
    }
}

void RouteFilter::Run() 
{
    if (!m_pMap) 
        return;

    if (g_VFVAPIVersion >= 12) 
    {
		const VDXPixmap& pxdst = *fa->dst.mpPixmap;
		const VDXPixmap& pxsrc = *fa->src.mpPixmap;

		switch(pxdst.format) {
			case nsVDXPixmap::kPixFormat_XRGB8888:
                Bitmap *pbmp = PrepareRGB32(pxdst.data, pxdst.pitch, pxdst.w, pxdst.h);
                DrawRoute(pbmp, fa->pfsi->lSourceFrameMS);
                ApplyRGB32(pbmp, pxdst.data, pxdst.pitch, pxdst.w, pxdst.h);
                delete pbmp;
				break;
		}
	} 
    else 
    {
        Bitmap *pbmp = PrepareRGB32(fa->dst.data, fa->dst.pitch, fa->dst.w, fa->dst.h);
        DrawRoute(pbmp, fa->pfsi->lSourceFrameMS);
        ApplyRGB32(pbmp, fa->dst.data, fa->dst.pitch, fa->dst.w, fa->dst.h);
        delete pbmp;
	}
}

Bitmap* RouteFilter::PrepareRGB32(void *data, uint32 pitch, uint32 w, uint32 h)
{
    //create bitmap on frame!
    Bitmap *pbmp = new Bitmap(w, h, pitch, PixelFormat32bppRGB, (BYTE*)data);
    return pbmp;

}

void RouteFilter::ApplyRGB32(Bitmap *pbmp, void *data, uint32 pitch, uint32 w, uint32 h)
{
    //do nothing
}

bool RouteFilter::Configure(VDXHWND hwnd) {
	RouteFilterDialog dlg(mConfig, fa->ifp);

	return dlg.Show((HWND)hwnd);
}

void RouteFilter::GetSettingString(char *buf, int maxlen) {
	SafePrintf(buf, maxlen, " (\"%s\")", mConfig.mFile);
}

void RouteFilter::GetScriptString(char *buf, int maxlen) {
	char file_c[1024];
	int j = 0;
	for(int i = 0; i < sizeof(mConfig.mFile) && mConfig.mFile[i] != 0 && j < sizeof(file_c); i++, j++)
	{
		if (mConfig.mFile[i] == '\\')
		{
			file_c[j++] = '\\';
		}
		file_c[j] = mConfig.mFile[i]; 
	}
	file_c[j] = 0;

	SafePrintf(buf, maxlen, "Config(\"%s\")", file_c);
}

void RouteFilter::DrawRoute(Bitmap *pbmp, uint32 ms) 
{
    //calculate current run time
    int32 time_run = ms-m_TimeOffset;
    if (time_run < 0)
    {
        time_run = 0;
    }

    //find current sample by run time
    pugi::xml_node current_sample = m_LastSample;
    if (current_sample.empty())
    {
        //get first sample
        current_sample = m_pPathDoc->child("Route").child("Segment").first_child();
    }
    //go forward
    double elapsed_time = current_sample.attribute("elapsedTime").as_double();
    while(time_run > (elapsed_time+1)*1000)
    {
        current_sample = current_sample.next_sibling();
        if (current_sample.empty())
        {
            //end of path reached
            current_sample = m_pPathDoc->child("Route").child("Segment").last_child();
            break;
        }
        elapsed_time = current_sample.attribute("elapsedTime").as_double();
    }
    //go backward
    while(time_run < elapsed_time*1000)
    {
        current_sample = current_sample.previous_sibling();
        if (current_sample.empty())
        {
            //begin of path reaches
            current_sample = m_pPathDoc->child("Route").child("Segment").first_child();;
            break;
        }
        elapsed_time = current_sample.attribute("elapsedTime").as_double();
    }

    //test if sample change
    if (m_LastSample.empty() || m_LastSample != current_sample)
    {
        //create bitmap
        if (m_pLastBmp)
        {
            delete m_pLastBmp;
        }
        m_pLastBmp = new Bitmap(pbmp->GetWidth(), pbmp->GetHeight(), PixelFormat32bppARGB);

        //draw into bitmap
        Graphics graphics(m_pLastBmp);
        Color clear_color(0,0,0,0);
        graphics.Clear(clear_color);

        //draw time text NOTE: samples must be each second!!! in other case time will be displayed with gaps
        WCHAR wstr[256];
        uint32 hour = (time_run/1000)/3600;
        uint32 min = ((time_run/1000)%3600)/60;
        uint32 sec = (time_run/1000)%60;
        wsprintfW(wstr, L"Время: %02i:%02i'%02i", hour, min, sec); 
        graphics.DrawString(wstr, wcslen(wstr), m_pTimeFont, m_TimePos, m_pTimeBrush); 

        //draw pace
        int pace_m = current_sample.attribute("pace").as_int();
        if (m_AvgTail > 1)  //NOTE: tail by samples, not by seconds
        {
            pugi::xml_node sample = current_sample.previous_sibling();
            for(int i = 1; i < m_AvgTail; i++)
            {
                if (!sample.empty())
                {
                    pace_m += sample.attribute("pace").as_int();
                    sample = sample.previous_sibling();
                }
                else
                {
                    pace_m += 30*60;
                }
            }
            pace_m /= m_AvgTail;
        }
        if (pace_m > 30*60)
        {
            pace_m = 0;
        }
        int pace_s = pace_m%60;
        pace_m /=60;
        wsprintfW(wstr, L"Темп: %i'%02i", pace_m, pace_s); 
        graphics.DrawString(wstr, wcslen(wstr), m_pPaceFont, m_PacePos, m_pPaceBrush);

        //draw logo
        if (m_pLogo)
        {
            ImageAttributes ImgAttr;
            ColorMatrix ClrMatrix = { 
                    1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 1.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, m_LogoOpaque/(100.0f), 0.0f,
                    0.0f, 0.0f, 0.0f, 0.0f, 1.0f
            };
            ImgAttr.SetColorMatrix(&ClrMatrix, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);
            Rect    destination(m_LogoX, m_LogoY, m_pLogo->GetWidth(), m_pLogo->GetHeight());
            graphics.DrawImage(m_pLogo, destination, 0, 0, m_pLogo->GetWidth(), m_pLogo->GetHeight(), UnitPixel, &ImgAttr);
        }

        int32 last_lap = m_LastSample.attribute("lapNumber").as_int();
        int32 cur_lap = current_sample.attribute("lapNumber").as_int();
        if (last_lap != cur_lap)
        {
            //rebuild leg data

            //1. collect all image positions
            m_LegPoints.clear();

            pugi::xml_node sample = current_sample;
            m_LegPositon = 0;
            //find start of leg
            while(!sample.previous_sibling().empty() && sample.previous_sibling().attribute("lapNumber").as_int() == cur_lap)
            {
                sample = sample.previous_sibling();
                m_LegPositon++;
            }
            //add all leg points to array
            while(!sample.empty() && sample.attribute("lapNumber").as_int() == cur_lap)
            {
                m_LegPoints.push_back(PointF(sample.attribute("imageX").as_int(), sample.attribute("imageY").as_int()));
                sample = sample.next_sibling();
            }

            //2. build matrix
            int samples = m_LegPoints.size();
            if (samples > 1)
            {
                PointF start(m_LegPoints[0].X, m_LegPoints[0].Y);
                PointF end(m_LegPoints[samples-1].X, m_LegPoints[samples-1].Y);
                PointF vector(end.X - start.X, end.Y - start.Y);
            
                PointF leg_center((end.X + start.X)/2, (end.Y + start.Y)/2);

                double vector_size = sqrt(vector.X*vector.X+vector.Y*vector.Y);

                if (fabs(vector.X) > 1 && fabs(vector.Y) > 1)
                {
                    double angle = atan2((double)(vector.Y), (double)(vector.X));
                    double leg_direction = 90.0+180.0*(angle)/M_PI;

                    if (m_pLegMatrix)
                    {
                        delete m_pLegMatrix;
                    }
                    m_pLegMatrix = new Matrix();
                    m_pLegMatrix->RotateAt(-leg_direction, leg_center);
                
                    PointF view_center(m_LegX+m_LegWidth/2, m_LegY+m_LegHeight/2);
                    double scale = (m_LegHeight - m_LegTreshold*2)/vector_size;
                    if (scale > 1) scale = 1;
                    m_pLegMatrix->Scale(scale, scale, MatrixOrderAppend);
                    m_pLegMatrix->Translate(view_center.X-leg_center.X*scale, view_center.Y-leg_center.Y*scale, MatrixOrderAppend);
                    REAL t4[6];
                    m_pLegMatrix->GetElements(t4);

                    m_pLegMatrix->TransformPoints(m_LegPoints.data(), samples);

                }
            }
        }

        //draw leg
        if (m_LegPoints.size() > 1)
        {
            GraphicsState state = graphics.Save();
            
            //TODO: set clip by region
            Rect clip_rect(m_LegX, m_LegY, m_LegWidth, m_LegHeight);
            graphics.SetClip(clip_rect);

            REAL t1[6];
            m_pLegMatrix->GetElements(t1);
            graphics.SetTransform(m_pLegMatrix);

            ColorMatrix ClrMatrix = { 
                    1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 1.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, m_PosOpaque/(100.0f), 0.0f,
                    0.0f, 0.0f, 0.0f, 0.0f, 1.0f
            };
            ImageAttributes ImgAttr;
            ImgAttr.SetColorMatrix(&ClrMatrix, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);

            Rect    destination(0, 0, m_pMap->GetWidth(), m_pMap->GetHeight());
            graphics.DrawImage(m_pMap, destination, 0, 0, m_pMap->GetWidth(), m_pMap->GetHeight(), UnitPixel, &ImgAttr);

            graphics.Restore(state);

            graphics.DrawLines(m_pPenLeg, m_LegPoints.data(), min(m_LegPoints.size(), m_LegPositon));
        }

        //draw current position
        if (m_pMap && m_PosWidth > 0 && m_PosHeight > 0)
        {
            GraphicsState state = graphics.Save();

            int32 image_x = current_sample.attribute("imageX").as_int();
            int32 image_y = current_sample.attribute("imageY").as_int();
            double head_direction = current_sample.attribute("direction").as_double();

            //TODO: clip by region
            Rect clip_rect(m_PosX, m_PosY, m_PosWidth, m_PosHeight);
            graphics.SetClip(clip_rect);

            Matrix rotate_at_map;
            PointF center(m_PosX+m_PosWidth/2, m_PosY+m_PosHeight/2);
            PointF image_pos(image_x, image_y);
            rotate_at_map.RotateAt(-head_direction, image_pos);
            rotate_at_map.Translate(center.X-image_x, center.Y-image_y, MatrixOrderAppend);
            graphics.SetTransform(&rotate_at_map);

            ColorMatrix ClrMatrix = { 
                    1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 1.0f, 0.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
                    0.0f, 0.0f, 0.0f, m_PosOpaque/(100.0f), 0.0f,
                    0.0f, 0.0f, 0.0f, 0.0f, 1.0f
            };
            ImageAttributes ImgAttr;
            ImgAttr.SetColorMatrix(&ClrMatrix, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);

            Rect    destination(0, 0, m_pMap->GetWidth(), m_pMap->GetHeight());
            graphics.DrawImage(m_pMap, destination, 0, 0, m_pMap->GetWidth(), m_pMap->GetHeight(), UnitPixel, &ImgAttr);

            //draw tail
            {
                int tail = m_PosTail;
                int last_x = image_x;
                int last_y = image_y;
                pugi::xml_node sample = current_sample.previous_sibling();
                while(tail-- > 0)
                {
                    if (sample.empty())
                    {
                        break;
                    }
                    int new_img_x = sample.attribute("imageX").as_int();
                    int new_img_y = sample.attribute("imageY").as_int();
                    graphics.DrawLine(m_pPenTail, last_x, last_y, new_img_x, new_img_y);
                    last_x = new_img_x;
                    last_y = new_img_y;
                    sample = sample.previous_sibling();
                }
            }

            graphics.Restore(state);

            //draw pointer
            {
                ImageAttributes ImgAttr;
                ColorMatrix ClrMatrix = { 
                        1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
                        0.0f, 1.0f, 0.0f, 0.0f, 0.0f,
                        0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
                        0.0f, 0.0f, 0.0f, m_PointerOpaque/(100.0f), 0.0f,
                        0.0f, 0.0f, 0.0f, 0.0f, 1.0f
                };
                ImgAttr.SetColorMatrix(&ClrMatrix, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);
                Rect    destination(m_PosX + m_PosWidth/2 - m_pPointer->GetWidth()/2, m_PosY + m_PosHeight/2 - m_pPointer->GetHeight()/2, m_pPointer->GetWidth(), m_pPointer->GetHeight());
                graphics.DrawImage(m_pPointer, destination, 0, 0, m_pPointer->GetWidth(), m_pPointer->GetHeight(), UnitPixel, &ImgAttr);
            }
        }
        m_LegPositon++;
        m_LastSample = current_sample;
    }

    //draw last bitmap
    if (m_pLastBmp)
    {
        Graphics gr_to(pbmp);
#if 0
        gr_to.DrawImage(m_pLastBmp, m_LegX, m_LegY, m_LegX, m_LegY, m_LegWidth, m_LegHeight, UnitPixel);
        gr_to.DrawImage(m_pLastBmp, m_PosX, m_PosY, m_PosX, m_PosY, m_PosWidth, m_PosHeight, UnitPixel);
        gr_to.DrawImage(m_pLastBmp, m_LogoX, m_LogoY, m_LogoX, m_LogoY, m_pLogo->GetWidth(), m_pLogo->GetHeight(), UnitPixel);
        //TODO: draw text? calc text rect?
        gr_to.DrawImage(m_pLastBmp, 0, 0, 0, 0, 200, 50, UnitPixel);
#else        
        gr_to.DrawImage(m_pLastBmp, 0, 0);
#endif
    }

    return;
}

void RouteFilter::ScriptConfig(IVDXScriptInterpreter *isi, const VDXScriptValue *argv, int argc) {
	strcpy_s(mConfig.mFile, 1024, *argv[0].asString());
}

///////////////////////////////////////////////////////////////////////////////

extern VDXFilterDefinition filterDef_RouteAdd = VDXVideoFilterDefinition<RouteFilter>("Vorfol", "Route add", "Add route.");
